Terraform Most IMP Interview Q/Aâ€™s
=============================================================
1) What is a state file in Terraform?
Ans: A state file is a file that Terraform uses to keep track of the current state of
the infrastructure. It maps the resources defined in the configuration to the
real-world resources.
Example: terraform show
Managing the state file is crucial because it ensures consistency between the
infrastructure's real state and the configuration. It also enables features like
change detection and planning. Example: terraform init
2) How can you secure the state file in Terraform?
Ans : State files can be secured by storing them in remote backends with proper
access controls and encryption, such as AWS S3 with server-side encryption and
access control policies.
Example:
terraform { backend "s3" {
bucket = "my-terraform-state"
key = "Infra/terraform.tfstate"
region = "us-west-2" encrypt = true } }
3) How do you manage different environments (e.g., dev, uat ,sit,
Pre-prod,prod) in Terraform?
Ans:
Different environments can be managed using workspaces or separate
directories with different variable files and state files.
Example:
terraform workspace new dev
terraform workspace new prod
4) How do you import existing resources into Terraform?
Ans : Existing resources can be imported using the terraform import command,
which maps the existing resource to a Terraform resource in the state file.
Example:
terraform import aws_instance.example i-1234567890abcdef0
5) How do you handle secrets in Terraform?
Ans :
Secrets can be managed using environment variables, secure secret
management services (e.g., AWS Secrets Manager), or Terraform's sensitive
attribute.
Example:
resource "aws_secretsmanager_secret" "example" {
name = "example"
description = "An example secret" }
resource "aws_secretsmanager_secret_version" "example" {
secret_id = aws_secretsmanager_secret.example.id
secret_string = jsonencode({
username = "example_user"
password = "example_password"
})
}
6) What is a Tf backend in Terraform?
Ans : A backend in Terraform defines where and how state is loaded and stored.
It can be local or remote (e.g., S3).
7) What is the difference between count and for_each in Terraform?
Ans :
â€œcount is used to create multiple instances of a resource, while for_each is used
to iterate over a map or set of values to create multiple instances.â€
Example (count):
resource "aws_instance" "example" {
count = 3
ami = "ami-0c55b159cbfafe1f0"
instance_type = "t2.micro"
}
Example (for_each):
resource "aws_instance" "example" {
for_each = toset(["instance1", "instance2"])
Ami = "ami-0c55b159cbfafe1f0"
instance_type = "t2.micro"
tags = {
Name = each.key
}
}
8)What are the locals in Terraform and how do you use them?
Ans :
â€œLocals in Terraform are used to define local values that can be reused within a
module. They help avoid repetition and make configurations more readable.â€
Example:
locals {
instance_type = "t2.micro"
ami_id = "ami-0c55b159cbfafe1f0"
}
resource "aws_instance" "example" {
Ami = local.ami_id
instance_type = local.instance_type
}
9)What is the purpose of the terraform taint command?
Ans :
â€œterraform taint marks a resource for recreation on the next terraform apply. It is
useful when a resource needs to be replaced due to a manual change or
corruption.â€
Example: terraform taint aws_instance.example
10) What is a null resource in terraform ?
Ans :
A null_resource in Terraform is a special resource that doesnâ€™t manage
any real infrastructure but allows you to run provisioners or scripts during
the apply phase.
None
ğŸ§© What Is null_resource?
The null_resource is part of the HashiCorp null provider and is used when
you want to execute actions (like scripts or commands) that arenâ€™t directly tied to
a specific infrastructure resource.
It supports the standard resource lifecycle (create, update, destroy) but doesnâ€™t
create any actual cloud resource. Instead, itâ€™s often used with provisioners like
local-exec or remote-exec.
âš™ï¸ Key Use Cases
â— Running scripts after provisioning (e.g., bootstrap tasks)
â— Triggering actions based on changes in input variables
â— Orchestrating workflows that depend on resource outputs
â— Workarounds when no native Terraform resource exists
ğŸ§ª Example: Run a Local Script After EC2 Creation
resource "aws_instance" "web" {
ami = "ami-0c55b159cbfafe1f0"
instance_type = "t2.micro"
}
resource "null_resource" "post_provision" {
provisioner "local-exec" {
command = "echo EC2 instance ${aws_instance.web.id}
created!"
}
None
triggers = {
instance_id = aws_instance.web.id
}
}
â— The triggers block ensures the null_resource is recreated if the EC2
instance changes.
â— The local-exec provisioner runs a shell command after the EC2
instance is created.
ğŸ”„ triggers Explained
The triggers argument is a map of arbitrary values. When any value changes,
the null_resource is replaced. This is how you control when the provisioner
re-runs.
triggers = {
timestamp = timestamp()
}
This forces the resource to run every time you apply.
What is a data Block in terraform ?How to pass existing data in terraform ?
Ans :
â€œIn Terraform, a data block is used to fetch and reference existing infrastructure
or external information without creating new resources. You pass existing data
using provider-specific data sources.â€
None
ğŸ“˜ What Is a data Block in Terraform?
A data block allows you to query existing resources or external metadata so
you can use them in your Terraform configuration. Itâ€™s read-only and doesnâ€™t
modify infrastructure.
Use cases include:
â— Referencing an existing AMI, VPC, subnet, or security group
â— Fetching secrets from AWS Secrets Manager or Azure Key Vault
â— Reading files, templates, or external APIs
ğŸ§© Syntax Example: Fetch Existing AWS AMI
data "aws_ami" "ubuntu" {
most_recent = true
owners = ["099720109477"] # Canonical
filter {
name = "name"
values =
["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server
-*"]
}
}
None
resource "aws_instance" "web" {
ami = data.aws_ami.ubuntu.id
instance_type = "t2.micro"
}
â— The data.aws_ami.ubuntu.id references the existing AMI.
â— No new AMI is createdâ€”Terraform just reads its metadata.
ğŸ” Example: Fetch Secret from AWS Secrets Manager
data "aws_secretsmanager_secret_version" "db_password"
{
secret_id = "prod/db_password"
}
output "db_password" {
value =
data.aws_secretsmanager_secret_version.db_password.secr
et_string
}
None
ğŸ“¦ Example: Read External File
data "template_file" "init_script" {
template = file("${path.module}/init.sh")
}
resource "aws_instance" "web" {
user_data = data.template_file.init_script.rendered
}
What will happen in the background if we pass terraform init ?
Ans :
When you run terraform init, Terraform initializes your working directory by
downloading provider plugins, setting up the backend, and preparing modules.
Itâ€™s the first step before any plan or apply.
What Happens Behind the Scenes with terraform init
Hereâ€™s a breakdown of the key background operations:
1. ğŸ“¦ Plugin Installation
â— Downloads required provider plugins (e.g., AWS, Azure, GCP) from the
Terraform Registry or other sources.
â— Stores them in the .terraform/plugins directory.
â— Ensures compatibility with your Terraform version.
Shell
2. ï¸ Backend Initialization
â— Configures the state backend (e.g., local, S3, Azure Blob, GCS).
â— If using remote backends, it may prompt for credentials or lock the state.
â— Validates backend settings and prepares for state storage.
3. ğŸ” Module Initialization
â— Downloads any external modules referenced in your configuration.
â— Stores them in .terraform/modules.
â— Ensures version constraints are respected.
4. ğŸ§ª Validation and Setup
â— Checks for syntax errors in your .tf files.
â— Prepares the directory for future commands like terraform plan and
terraform apply.
5. ğŸ§¹ Cleanup and Reinitialization
â— If re-run, it cleans up and reinitializes plugins/modules safely.
â— Useful when switching providers, updating modules, or changing backend
configs.
ğŸ§© Example Output
Initializing the backend...
Initializing provider plugins...
- Finding hashicorp/aws versions matching ">= 3.0.0"...
- Installing hashicorp/aws v5.0.0...
Terraform has been successfully initialized!
âœ… Best Practices
â— Run terraform init after cloning a repo or modifying backend/module
settings.
â— Safe to run multiple timesâ€”it wonâ€™t overwrite your state.
â— Use terraform init -upgrade to refresh plugins and modules.
What will happen in the background if we apply the terraform plan command ?
Ans :
â€œWhen you run a terraform plan, Terraform creates an execution plan by
comparing your configuration files to the current state of your infrastructure. It
shows what will change, without making any actual changesâ€.
ğŸ” What Happens Behind the Scenes with terraform plan
Hereâ€™s a detailed breakdown of the background operations:
1. ğŸ“¥ Load Configuration
â— Terraform reads all .tf files in your working directory.
â— It parses variables, providers, modules, and resource definitions.
2. ğŸ“¦ Initialize Providers
â— Loads provider plugins (e.g., AWS, Azure, GCP) from .terraform directory.
â— Validates provider versions and credentials.
3. ğŸ“Š Read Current State
â— Loads the current state from the backend (local or remote like S3, GCS, etc.).
â— If remote, it may lock the state file to prevent concurrent changes.
4. ğŸ” Query Real Infrastructure
â— Contacts cloud providers to fetch the actual state of resources.
â— Ensures Terraformâ€™s state file is in sync with reality (detects drift).
5. ğŸ” Compare Desired vs Actual State
â— Compares your configuration (.tf files) with the current state.
â— Identifies additions (+), changes (~), and deletions (-).
Shell
6. ğŸ“‹ Generate Execution Plan
â— Outputs a detailed plan showing what will happen if you run terraform apply.
â— No changes are madeâ€”this is a dry run.
Example Output:
~ aws_instance.web
 instance_type: "t2.micro" => "t3.micro"
Why terraform plan Is Critical
â— Prevents surprises: You see what will change before it happens.
â— Detects drift: Highlights manual changes made outside Terraform.
â— Validates logic: Ensures your configuration is syntactically and semantically
correct.
â— Supports CI/CD: Often used in pipelines to gate deployments.
ğŸš€ Pro Tips
â— Use terraform plan -out=tfplan to save the plan for later use with
terraform apply tfplan.
â— Use terraform plan -var-file="prod.tfvars" for environment-specific
planning.
â— Combine with terraform validate for full pre-deployment checks.
ğŸ” What Is the Terraform Lockfile?
Ans :
The Terraform lockfile (.terraform.lock.hcl) is a dependency tracking file that
ensures consistent provider versions across environments. It prevents
unexpected upgrades or mismatches.
ğŸ” What Is the Terraform Lockfile?
None
â— Filename: .terraform.lock.hcl
â— Purpose: Records exact versions and checksums of provider plugins used in
your configuration.
â— Scope: Ensures reproducibility across teams, CI/CD pipelines, and
environments.
Why It Matters:
â— Prevents breaking changes from provider updates
â— Ensures consistent behavior across machines
â— Supports secure checksum validation of downloaded plugins
ğŸ“¦ Example Lockfile Snippet
provider "registry.terraform.io/hashicorp/aws" {
 version = "5.0.0"
 constraints = ">= 3.0.0"
 hashes = [
 "h1:abc123...",
 "zh:xyz456..."
 ]
}
ğŸ”“ How to Unlock or Update the Lockfile
You donâ€™t â€œunlockâ€ it like a state lockâ€”you regenerate or update it:
âœ… To Refresh Provider Versions:
Shell
Shell
terraform init -upgrade
â— Re-downloads latest allowed versions based on constraints
â— Updates .terraform.lock.hcl with new checksums
ğŸ§¹ To Delete and Recreate:
rm .terraform.lock.hcl
terraform init
â— Removes the lockfile and reinitializes it from scratch
ğŸ” To Manually Edit:
â— You can edit the file, but itâ€™s not recommendedâ€”use terraform init
-upgrade instead.
Best Practices
â— Commit the lockfile to version control (especially in teams)
â— Use version constraints in required_providers to control upgrades
â— Regenerate lockfile only when you intend to upgrade providers
Write Sample terraform code to create an ec2 instance ?
Write a Sample terraform code to create VPC & Subnet creation ?
Write a Sample terraform code to create an S3 bucket that enables s3 versioning?
What are Terraform basic commands ?
Terraform init
Terraform validate
Terraform plan
Terraform apply
Terraform destroy
